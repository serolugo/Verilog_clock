module temp(
	input  wire       clk,        // 50 MHz
   input  wire       reset,        // reset ACTIVO EN ALTO
   input  wire [2:0] btn,        // botones (0: start/stop, 1: reset chrono)
   input  wire       clk_1khz,   // 1 kHz

   output wire [3:0] min_tens,
   output wire [3:0] min_ones,
   output wire [3:0] sec_tens,
   output wire [3:0] sec_ones,
   output wire [3:0] ms_tens,
   output wire [3:0] ms_ones
	
);

assign rst = !reset || !btn[1];

    // -------------------------------
    // 1) Sincronizar clk_1khz al dominio de 50 MHz
    // -------------------------------
    reg k1_ff0, k1_ff1;

    always @(posedge clk) begin
        if (rst) begin
            k1_ff0 <= 1'b0;
            k1_ff1 <= 1'b0;
        end else begin
            k1_ff0 <= clk_1khz;
            k1_ff1 <= k1_ff0;
        end
    end
	 
	 // Pulso de 1 ciclo de 50 MHz en el flanco de subida de clk_1khz (1 ms)
    wire tick_1khz_pos = k1_ff0 & ~k1_ff1;

    // -------------------------------
    // 2) Divisor 10 → 100 Hz (10 ms)
    //    Para tener 2 dígitos de “milisegundos” (00–99)
    // -------------------------------
    reg [3:0] div10;
    wire tick_100hz;

    assign tick_100hz = (div10 == 4'd9) & tick_1khz_pos;

    always @(posedge clk) begin
        if (rst) begin
            div10 <= 4'd0;
        end else if (tick_1khz_pos) begin
            if (div10 == 4'd9)
                div10 <= 4'd0;
            else
                div10 <= div10 + 4'd1;
        end
    end
	 
	 // -------------------------------
    // 3) Lógica de control start/stop
    //    - btn[0] activo en bajo: toggle
    //    - btn[1] activo en bajo: reset de cronómetro
    // -------------------------------
    // Sincronizar btn[0] al clk y detectar flanco de bajada
    reg [1:0] btn0_sync;

    always @(posedge clk) begin
        if (rst)
            btn0_sync <= 2'b11;   // asumimos que el botón "suelto" está en 1
        else
            btn0_sync <= {btn0_sync[0], btn[0]};
    end